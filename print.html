<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Pikelet Language Book</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Documentation for the Pikelet Language">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        
        <!-- MathJax -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <noscript>
            <style type="text/css">
                .javascript-only {
                    display: none;
                }
            </style>
        </noscript>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="index.html">Pikelet</a></li><li><a href="installation/index.html"><strong aria-hidden="true">1.</strong> Installation</a></li><li><a href="language/index.html"><strong aria-hidden="true">2.</strong> Language</a></li><li><a href="appendix/index.html"><strong aria-hidden="true">3.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix/theory.html"><strong aria-hidden="true">3.1.</strong> Theory</a></li><li><a href="appendix/references.html"><strong aria-hidden="true">3.2.</strong> References</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons javascript-only">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Pikelet Language Book</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="searchbar-outer" class="searchbar-outer">
                    <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                </div>
                <div id="searchresults-outer" class="searchresults-outer">
                    <div class="searchresults-header" id="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="print.html#pikelet-" id="pikelet-"><h1>Pikelet 🥞</h1></a>
<p>Pikelet is a small <a href="https://en.wikipedia.org/wiki/Dependent_type">dependently typed</a> language. It
doesn't do many interesting things yet, but hopefully that will change in the future!</p>
<ul>
<li><a href="https://github.com/brendanzab/pikelet">Source code</a></li>
<li><a href="https://github.com/brendanzab/pikelet/issues">Issues</a></li>
<li><a href="https://gitter.im/pikelet-lang/Lobby">Gitter Chat</a></li>
</ul>
<a class="header" href="print.html#a-small-taste" id="a-small-taste"><h2>A small taste</h2></a>
<p>Definitions:</p>
<pre><code class="language-pikelet">module prelude;

id : (a : Type) -&gt; a -&gt; a;
id a x = x;

const : (a b : Type) -&gt; a -&gt; b -&gt; a;
const a b x y = x;
</code></pre>
<p>Interactive REPL:</p>
<pre><code class="language-pikelet-repl">$ cargo run repl
    ____  _ __        __     __
   / __ \(_) /_____  / /__  / /_
  / /_/ / / //_/ _ \/ / _ \/ __/    Version 0.1.0
 / ____/ / ,&lt; /  __/ /  __/ /_      https://github.com/brendanzab/pikelet
/_/   /_/_/|_|\___/_/\___/\__/      :? for help

Pikelet&gt; (\(a : Type) (x: a) =&gt; x) String &quot;hello&quot;
&quot;hello&quot; : #String
Pikelet&gt; :t Type
Type 1
Pikelet&gt; 1 : I16
1 : #I16
Pikelet&gt;
</code></pre>
<a class="header" href="print.html#what-is-a-pikelet" id="what-is-a-pikelet"><h2>What is a Pikelet?</h2></a>
<p>A pikelet is an odd sort of small (often pre-made) pancake found in Australia
and New Zealand. Commonly sent in school lunches spread with jam and butter.
Handily it also has a name that includes 'pi' and 'let' as substrings! 😅</p>
<a class="header" href="print.html#installation" id="installation"><h1>Installation</h1></a>
<p>Pikelet is written in <a href="https://www.rust-lang.org/">Rust</a> and therefore needs to be compiled with
Cargo, because we don't yet offer prebuilt binaries. If you haven't already
installed Rust, please <a href="https://www.rust-lang.org/downloads.html">install it</a> now!</p>
<a class="header" href="print.html#cloning-the-source-from-github" id="cloning-the-source-from-github"><h2>Cloning the source from Github</h2></a>
<p>We've not yet published Pikelet on <a href="https://crates.io/">crates.io</a>, so you'll first need
to clone <a href="https://github.com/brendanzab/pikelet">the repository</a> using git:</p>
<pre><code class="language-sh">git clone https://github.com/brendanzab/pikelet.git
cd pikelet
</code></pre>
<a class="header" href="print.html#running-the-repl" id="running-the-repl"><h2>Running the REPL</h2></a>
<p>After cloning, you can now run the <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a> using Cargo:</p>
<pre><code class="language-sh">cargo run repl
</code></pre>
<p>You will now need to wait for cargo to download and build the dependencies, but
sooner or later the REPL will be ready for you to interact with!</p>
<a class="header" href="print.html#language" id="language"><h1>Language</h1></a>
<a class="header" href="print.html#contents" id="contents"><h2>Contents</h2></a>
<ul>
<li><a href="print.html#comments">Comments</a></li>
<li><a href="print.html#built-in-types-and-their-literals">Built-in types and their literals</a></li>
<li><a href="print.html#type-annotations">Type annotations</a></li>
<li><a href="print.html#types-of-types">Types of types</a></li>
<li><a href="print.html#identifiers">Identifiers</a></li>
<li><a href="print.html#functions">Functions</a></li>
</ul>
<a class="header" href="print.html#comments" id="comments"><h2>Comments</h2></a>
<p>In Pikelet, line comments are proceeded by a double dash:</p>
<pre><code class="language-pikelet">-- this is a comment!
</code></pre>
<p>Doc comments are proceeded by a triple pipe:</p>
<pre><code class="language-pikelet">||| This is a doc comment!
</code></pre>
<a class="header" href="print.html#built-in-types-and-their-literals" id="built-in-types-and-their-literals"><h2>Built-in types and their literals</h2></a>
<p>Pikelet has a number of fundamental types:</p>
<table><thead><tr><th> Type     </th><th> Literal                                </th></tr></thead><tbody>
<tr><td> <code>String</code> </td><td> <code>&quot;hello there!&quot;</code>                       </td></tr>
<tr><td> <code>Char</code>   </td><td> <code>'a'</code>, <code>'b'</code>, ..., <code>'\n'</code>, <code>'\t'</code>, ... </td></tr>
<tr><td> <code>U8</code>     </td><td> <code>1</code>, <code>2</code>, <code>3</code>, ...                     </td></tr>
<tr><td> <code>U16</code>    </td><td> <code>1</code>, <code>2</code>, <code>3</code>, ...                     </td></tr>
<tr><td> <code>U32</code>    </td><td> <code>1</code>, <code>2</code>, <code>3</code>, ...                     </td></tr>
<tr><td> <code>U64</code>    </td><td> <code>1</code>, <code>2</code>, <code>3</code>, ...                     </td></tr>
<tr><td> <code>I8</code>     </td><td> <code>1</code>, <code>2</code>, <code>3</code>, ...                     </td></tr>
<tr><td> <code>I16</code>    </td><td> <code>1</code>, <code>2</code>, <code>3</code>, ...                     </td></tr>
<tr><td> <code>I32</code>    </td><td> <code>1</code>, <code>2</code>, <code>3</code>, ...                     </td></tr>
<tr><td> <code>I64</code>    </td><td> <code>1</code>, <code>2</code>, <code>3</code>, ...                     </td></tr>
<tr><td> <code>F32</code>    </td><td> <code>1</code>, <code>2</code>, <code>3</code>, ..., <code>0.0</code>, <code>1.0</code>, ...  </td></tr>
<tr><td> <code>F64</code>    </td><td> <code>1</code>, <code>2</code>, <code>3</code>, ..., <code>0.0</code>, <code>1.0</code>, ...  </td></tr>
</tbody></table>
<blockquote>
<p><strong>Note:</strong> You can't do much with these built-in types yet. In the future we
will add some primitive operations to allow you to maniplate them.</p>
</blockquote>
<a class="header" href="print.html#type-annotations" id="type-annotations"><h2>Type annotations</h2></a>
<p>If you note <a href="print.html#built-in-types-and-their-literals">above</a>, a number of the
built-in types share a literal representation. Pikelet will try to predictably
infer the types, but if it fails to do so you will get an error. In that case
you can use the type annotation operator, <code>(:)</code>, to specify the intended type:</p>
<pre><code class="language-pikelet-repl">Pikelet&gt; 1           -- error: ambiguous integer literal
Pikelet&gt; 1 : I32     -- ok!
Pikelet&gt; 1 : F32     -- ok!
Pikelet&gt; 1.0 : F32   -- ok!
Pikelet&gt; 1.1 : U64   -- error: expected a floating point value
</code></pre>
<a class="header" href="print.html#types-of-types" id="types-of-types"><h2>Types of types</h2></a>
<p>Types also have types!</p>
<pre><code class="language-pikelet-repl">Pikelet&gt; :t I32           -- ok: Type
</code></pre>
<p>You might then ask, “what is the type of <code>Type</code>?”</p>
<pre><code class="language-pikelet-repl">Pikelet&gt; :t Type          -- ok: Type 1
</code></pre>
<p>Note that <code>Type</code> is actually just syntactic sugar for <code>Type 0</code>:</p>
<pre><code class="language-pikelet-repl">Pikelet&gt; :t Type 0        -- ok: Type 1
</code></pre>
<p>In fact Pikelet has an infinte number of 'universes', each one 'bigger' than the
previous:</p>
<pre><code class="language-pikelet">Type 0 : Type 1 : Type 2 : Type 3 : ...
</code></pre>
<p>You can think of these as larger and larger sets, with the smaller type
universes being contained within the larger type universes:</p>
<blockquote>
<p>TODO: Put a nice SVG diagram of the sets of types here</p>
<pre><code>(Type 2
  (Type 1
    (Type 0
      (I32, F32, String,
        (1, 4.0, &quot;hello&quot;)))))
</code></pre>
</blockquote>
<a class="header" href="print.html#identifiers" id="identifiers"><h2>Identifiers</h2></a>
<blockquote>
<p>TODO</p>
</blockquote>
<a class="header" href="print.html#functions" id="functions"><h2>Functions</h2></a>
<a class="header" href="print.html#simply-typed-functions" id="simply-typed-functions"><h3>Simply typed functions</h3></a>
<p>Here are some simple functions and their types:</p>
<pre><code class="language-pikelet-repl">Pikelet&gt; :t \x : I32    =&gt; x                          -- ok: I32 -&gt; I32
Pikelet&gt; :t \x : String =&gt; x                          -- ok: String -&gt; String
Pikelet&gt; :t \x : Char   =&gt; x                          -- ok: Char -&gt; Char
</code></pre>
<p>Note that all of these types follow the same pattern - they are the identity
function! This means that if you pass a value to them, they'll return the same
thing without alteration!</p>
<pre><code class="language-pikelet-repl">Pikelet&gt; (\x : I32    =&gt; x) 42                        -- ok: 42 : I32
Pikelet&gt; (\x : String =&gt; x) &quot;hi&quot;                      -- ok: &quot;hi&quot; : String
Pikelet&gt; (\x : Char   =&gt; x) 'b'                       -- ok: 'b' : Char
</code></pre>
<a class="header" href="print.html#polymorphic-functions" id="polymorphic-functions"><h3>Polymorphic functions</h3></a>
<p>Alas, we can't reuse one of these identity functions with other, incompatible
types:</p>
<pre><code class="language-pikelet-repl">Pikelet&gt; (\x : I32    =&gt; x) 4.0                       -- error!
Pikelet&gt; (\x : String =&gt; x) 'b'                       -- error!
Pikelet&gt; (\x : Char   =&gt; x) &quot;yoho&quot;                    -- error!
</code></pre>
<p>Let's make this identity function polymorphic by adding a parameter for the type
of the argument:</p>
<pre><code class="language-pikelet-repl">Pikelet&gt; :t \(a : Type) (x : a) =&gt; x                  -- ok: (a : Type) -&gt; a -&gt; a
</code></pre>
<p>We now have a polymorphic identity function! We can specialise this function by
applying a type to it:</p>
<pre><code class="language-pikelet-repl">Pikelet&gt; (\(x : Type) (x : a) =&gt; x) String &quot;hello&quot;    -- ok: &quot;hello&quot; : String
Pikelet&gt; (\(x : Type) (x : a) =&gt; x) I32 1             -- ok: 1 : I32
</code></pre>
<a class="header" href="print.html#syntactic-sugar-for-functions" id="syntactic-sugar-for-functions"><h3>Syntactic Sugar for functions</h3></a>
<p>In Pikelet all functions take a single argument - in order to pass multiple
arguments we use currying. The following functions are equivalent:</p>
<pre><code class="language-pikelet">\(x : Type) (x : a) =&gt; x
\(x : Type) =&gt; \(x : a) =&gt; x
</code></pre>
<p>Non-dependent functions can be expressed without explicit parameter names. For
example the following function types are equivalent:</p>
<pre><code class="language-pikelet">(a : Type) (x : a) -&gt; a
(a : Type) -&gt; (x : a) -&gt; a
(a : Type) -&gt; a -&gt; a
</code></pre>
<a class="header" href="print.html#appendix" id="appendix"><h1>Appendix</h1></a>
<p>Here you will find additional reference information for understanding the
theoretical foundations behind Pikelet.</p>
<a class="header" href="print.html#theory" id="theory"><h1>Theory</h1></a>
<p>A formalization of the semantics for type checking and normalizing Pikelet.</p>
<a class="header" href="print.html#contents-1" id="contents-1"><h2>Contents</h2></a>
<ul>
<li><a href="print.html#introduction">Introduction</a>
<ul>
<li><a href="print.html#notation">Notation</a></li>
</ul>
</li>
<li><a href="print.html#syntax">Syntax</a>
<ul>
<li><a href="print.html#raw-terms">Raw terms</a></li>
<li><a href="print.html#terms">Terms</a></li>
<li><a href="print.html#values">Values</a></li>
<li><a href="print.html#contexts">Contexts</a></li>
</ul>
</li>
<li><a href="print.html#semantics">Semantics</a>
<ul>
<li><a href="print.html#elaboration">Elaboration</a></li>
<li><a href="print.html#normalization">Normalization</a></li>
<li><a href="print.html#type-checking">Type checking</a></li>
<li><a href="print.html#type-inference">Type inference</a></li>
</ul>
</li>
</ul>
<a class="header" href="print.html#introduction" id="introduction"><h2>Introduction</h2></a>
<p>At its core, Pikelet is a dependently typed lambda calculus with a stratified
universe hierarchy.</p>
<blockquote>
<p><strong>Note:</strong>
This document is intended for those who are interested in looking deeper into the formal foundations of Pikelet.
You <em>don't</em> need to understand this for general use of Pikelet, so feel free to skip this document if that is easier.
We will however make an effort to explain some of the notation we use here, and point to resources that might help if this piques your curiosity!</p>
</blockquote>
<a class="header" href="print.html#notation" id="notation"><h3>Notation</h3></a>
<p>TODO: describe BNF syntax and natural deduction here</p>
<a class="header" href="print.html#syntax" id="syntax"><h2>Syntax</h2></a>
<a class="header" href="print.html#raw-terms" id="raw-terms"><h3>Raw terms</h3></a>
<p>\[
\newcommand{\rule}[3]{ \dfrac{ ~~#2~~ }{ ~~#3~~ } &amp; \Tiny{\text{(#1)}} }
\
\DeclareMathOperator{\max}{max}
\
% Judgements
\newcommand{\eval}[3]{ #1 \vdash #2 \Rightarrow #3 }
\newcommand{\check}[4]{ #1 \vdash #2 \uparrow #3 \rhd #4 }
\newcommand{\infer}[4]{ #1 \vdash #2 \downarrow #3 \rhd #4 }
\
% Metavariables
\newcommand{\rexpr}{r}
\newcommand{\rtype}{R}
\
\newcommand{\texpr}{t}
\newcommand{\ttype}{T}
\
\newcommand{\vexpr}{v}
\newcommand{\vtype}{V}
\newcommand{\wexpr}{w}
\newcommand{\wtype}{W}
\newcommand{\nexpr}{n}
\newcommand{\ntype}{N}
\
% Term and Type constructors
\newcommand{\const}{c}
\newcommand{\Type}{\mathsf{Type}}
\newcommand{\Arrow}[2]{ #1 \rightarrow #2 }
\newcommand{\Pi}[2]{ \Arrow{(#1)}{#2} }
\newcommand{\lam}[2]{ \lambda #1 . #2 }
\
\begin{array}{rrll}
\rexpr,\rtype   &amp; ::= &amp; x                           &amp; \text{variables} \\
&amp;   | &amp; \Type_i                     &amp; \text{universe of types ($i \in \mathbb{N}$)} \\
&amp;   | &amp; ?                           &amp; \text{holes} \\
&amp;   | &amp; \const                      &amp; \text{constants} \\
&amp;   | &amp; \rexpr : \rtype             &amp; \text{term annotated with a type} \\
&amp;   | &amp; \Pi{x:\rtype_1}{\rtype_2}   &amp; \text{dependent function type} \\
&amp;   | &amp; \lam{x:\rtype}{\rexpr}      &amp; \text{functions} \\
&amp;   | &amp; \rexpr_1 ~ \rexpr_2         &amp; \text{function application} \\
\\
\end{array}
\]</p>
<p>\[
\begin{array}{lrll}
\Arrow{\rtype_1}{\rtype_2} &amp; := &amp; \Pi{x:\rtype_1}{\rtype_2} &amp; \text{non-dependent function types} \\
\lam{x}{\rexpr}            &amp; := &amp; \lam{x:?}{\rexpr}         &amp; \text{functions (without an annotation)} \\
\end{array}
\]</p>
<a class="header" href="print.html#terms" id="terms"><h3>Terms</h3></a>
<p>The core term syntax skips holes, ensuring that everything is fully elaborated:</p>
<p>\[
\begin{array}{rrll}
\texpr,\ttype   &amp; ::= &amp; x                           &amp; \text{variables} \\
&amp;   | &amp; \Type_i                     &amp; \text{universe of types ($i \in \mathbb{N}$)} \\
&amp;   | &amp; \const                      &amp; \text{constants} \\
&amp;   | &amp; \texpr : \ttype             &amp; \text{term annotated with a type} \\
&amp;   | &amp; \Pi{x:\ttype_1}{\ttype_2}   &amp; \text{dependent function type} \\
&amp;   | &amp; \lam{x:\ttype}{\texpr}      &amp; \text{functions} \\
&amp;   | &amp; \texpr_1 ~ \texpr_2         &amp; \text{function application} \\
\\
\end{array}
\]</p>
<a class="header" href="print.html#values" id="values"><h3>Values</h3></a>
<p>In order to make it clear what is 'stuck' and what still needs to be evaluated,
we separate our syntax into weak head normal forms (\(\wexpr\)),
and neutral terms (\(\nexpr\)):</p>
<p>\[
\begin{array}{rrll}
\vexpr,\vtype   &amp; ::= &amp; \wexpr                      &amp; \text{weak head normal forms} \\
&amp;   | &amp; \nexpr                      &amp; \text{neutral terms} \\
\\
\nexpr,\ntype   &amp; ::= &amp; x                           &amp; \text{variables} \\
&amp;   | &amp; \nexpr ~ \texpr             &amp; \text{function application} \\
\\
\wexpr,\wtype   &amp; ::= &amp; \Type_i                     &amp; \text{universe of types ($i \in \mathbb{N}$)} \\
&amp;   | &amp; \const                      &amp; \text{constants} \\
&amp;   | &amp; \Pi{x:\vtype_1}{\vtype_2}   &amp; \text{dependent function type} \\
&amp;   | &amp; \lam{x:\vtype}{\vexpr}      &amp; \text{functions} \\
\\
\end{array}
\]</p>
<p>Note that function application is stuck,
forming a linked list of terms bottoming out with a variable \(x\).
We require neutral terms to be evaluated in a context in order to figure out  whether the base variable is a function or not,
and if so proceed to reduce these applications to their weak head normal forms via subsititution.</p>
<a class="header" href="print.html#contexts" id="contexts"><h3>Contexts</h3></a>
<p>As we typecheck terms, we'll be passing over bindings like lambdas and pi types.
Contexts allow us to keep track of the bound parameters,
even though we don't know the exact values these will eventually take during normalization.</p>
<p>\[
\begin{array}{rrll}
\Gamma  &amp; ::= &amp; \epsilon              &amp; \text{the empty context} \\
&amp;   | &amp; \Gamma,x:\vtype       &amp; \text{context extended with a type claim} \\
&amp;   | &amp; \Gamma,x=\texpr       &amp; \text{context extended with a definition} \\
\end{array}
\]</p>
<a class="header" href="print.html#semantics" id="semantics"><h2>Semantics</h2></a>
<p>We take a <em>bidirectional</em> approach to type checking, splitting it into two
phases: type checking and type inference. This makes the flow of information
through the type checker clear and relatively easy to reason about.
Normalization happens after inference, and before types are fed back in to be
used during type checkiong.</p>
<p>With that in mind, the next sections will describe the following judgements:</p>
<table><thead><tr><th> name                              </th><th> notation                                             </th><th> inputs                                   </th><th> outputs                    </th></tr></thead><tbody>
<tr><td> <a href="print.html#normalization">normalization</a>   </td><td> \(\eval{ \Gamma }{ \texpr }{ \vexpr }\)            </td><td> \(\Gamma\), \(\rexpr\)               </td><td> \(\vexpr\)               </td></tr>
<tr><td> <a href="print.html#type-checking">type checking</a>   </td><td> \(\check{ \Gamma }{ \rexpr }{ \vtype }{ \texpr }\) </td><td> \(\Gamma\), \(\rexpr\), \(\vtype\) </td><td> \(\texpr\)               </td></tr>
<tr><td> <a href="print.html#type-inference">type inference</a> </td><td> \(\infer{ \Gamma }{ \rexpr }{ \vtype }{ \texpr }\) </td><td> \(\Gamma\), \(\rexpr\)               </td><td> \(\vtype\), \(\texpr\) </td></tr>
</tbody></table>
<p>Normalization stands on its own, but both checking and inference are mutually
dependent on each other. Care has been taken to design the judgments so that
they are <em>syntax-directed</em>, meaning that an algorithm can be clearly derived
from them.</p>
<p>Here is a rough overview of how Pikelet terms are checked:</p>
<pre><code>                (from parser)
                      |
                      v
     +------------ RawTerm -----------+
     |                                |
     v                                v
Type Inference &lt;- - - - - - -&gt; Type checking
     |                                ^
     |                                |
   Term                             Value
     |                                |
     +-------&gt; Normalization ---------+
     |
     |
     v
 (to compiler)
</code></pre>
<!-- TODO: use SVG for this diagram -->
<a class="header" href="print.html#elaboration" id="elaboration"><h3>Elaboration</h3></a>
<p>Elaboration is the process of filling in missing information that the
programmer omitted in the original code, generally based on the results
of type inference.</p>
<p>In Pikelet's judgements the elaborated terms are denoted after the
diamond: \(\rhd\). At the moment not much is added - only the missing
type annotations on function parameters. In the future this could be extended
filling in type class instances and implicit arguments.</p>
<a class="header" href="print.html#normalization" id="normalization"><h3>Normalization</h3></a>
<p>Here we describe how we normalize elaborated terms under the assumptions
in the context.</p>
<p>\[
\boxed{
\eval{ \Gamma }{ \texpr }{ \vexpr }
}
\\[2em]
\begin{array}{cl}
\rule{E-ANN}{
\eval{ \Gamma }{ \texpr }{ \vexpr }
}{
\eval{ \Gamma }{ \texpr:\ttype }{ \vexpr }
}
\\[2em]
\rule{E-TYPE}{}{
\eval{ \Gamma }{ \Type_i }{ \Type_i }
}
\\[2em]
\rule{E-CONST}{}{
\eval{ \Gamma }{ \const }{ \const }
}
\\[2em]
\rule{E-VAR}{
x=\texpr \notin \Gamma
}{
\eval{ \Gamma }{ x }{ x }
}
\\[2em]
\rule{E-VAR-DEF}{
x=\texpr \in \Gamma
\qquad
\eval{ \Gamma }{ \texpr }{ \vexpr }
}{
\eval{ \Gamma }{ x }{ \vexpr }
}
\\[2em]
\rule{E-PI}{
\eval{ \Gamma }{ \ttype_1 }{ \vtype_1 }
\qquad
\eval{ \Gamma, x:\vtype_1 }{ \ttype_2 }{ \vtype_2 }
}{
\eval{ \Gamma }{ \Pi{x:\ttype_1}{\ttype_2} }{ \Pi{x:\vtype_1}{\vtype_2} }
}
\\[2em]
\rule{E-LAM}{
\eval{ \Gamma }{ \ttype }{ \vtype }
\qquad
\eval{ \Gamma, x:\vtype }{ \texpr }{ \vexpr }
}{
\eval{ \Gamma }{ \lam{x:\ttype}{\texpr} }{ \lam{x:\vtype}{\vexpr} }
}
\\[2em]
\rule{E-APP}{
\eval{ \Gamma }{ \texpr_1 }{ \lam{x:\vtype_1}{\vexpr_1} }
\qquad
\eval{ \Gamma, x=\vexpr_2 }{ \vexpr_1 }{ \vexpr_1' }
}{
\eval{ \Gamma }{ \texpr_1 ~ \texpr_2 }{ \vexpr_1' }
}
\\[2em]
\end{array}
\]</p>
<a class="header" href="print.html#type-checking" id="type-checking"><h3>Type checking</h3></a>
<p>This judgement checks that the given term has the expected type and returns its
elaborated form.</p>
<p>\[
\boxed{
\check{ \Gamma }{ \rexpr }{ \vtype }{ \texpr }
}
\\[2em]
\begin{array}{cl}
\rule{C-LAM}{
\infer{ \Gamma,x:\vtype_1 }{ \rexpr }{ \ttype_2 }{ \texpr }
}{
\check{ \Gamma }{ \lam{x:?}{\rexpr} }{ \Pi{x:\vtype_1}{\vtype_2} }{ \lam{x:\vtype_1}{\texpr} }
}
\\[2em]
\rule{C-CONV}{
\infer{ \Gamma }{ \rexpr }{ \vtype_2 }{ \texpr }
\qquad
\vtype_1 \equiv_{\alpha} \vtype_2
}{
\check{ \Gamma }{ \rexpr }{ \vtype_1 }{ \texpr }
}
\\[2em]
\end{array}
\]</p>
<p>In C-CONV we flip the direction of the type checker, comparing the type of the
expected term for <a href="https://en.wikipedia.org/wiki/Lambda_calculus#Alpha_equivalence">alpha equivalence</a> with the inferred term. Note that we could
alternatively check for subtyping instead of alpha equivalence. This could be
useful for implementing a cumulative universe hierarchy.</p>
<a class="header" href="print.html#type-inference" id="type-inference"><h3>Type inference</h3></a>
<p>Here we define a jugement that synthesizes a type from the given term and
returns its elaborated form.</p>
<p>\[
\boxed{
\infer{ \Gamma }{ \rexpr }{ \vtype }{ \texpr }
}
\\[2em]
\begin{array}{cl}
\rule{I-ANN}{
\infer{ \Gamma }{ \rtype }{ \Type_i }{ \ttype }
\qquad
\eval{ \Gamma }{ \ttype }{ \vtype }
\qquad
\check{ \Gamma }{ \rexpr }{ \vtype }{ \texpr }
}{
\infer{ \Gamma }{ \rexpr:\rtype }{ \Type_{i+1} }{ \texpr:\ttype }
}
\\[2em]
\rule{I-TYPE}{}{
\infer{ \Gamma }{ \Type_i }{ \Type_{i+1} }{ \Type_i }
}
\\[2em]
\rule{I-VAR}{
x:\vtype \in \Gamma
}{
\infer{ \Gamma }{ x }{ \vtype }{ x }
}
\\[2em]
\rule{I-PI}{
\infer{ \Gamma }{ \rtype_1 }{ \Type_i }{ \ttype_1 }
\qquad
\eval{ \Gamma }{ \ttype_1 }{ \vtype_1 }
\qquad
\check{ \Gamma, x:\vtype_1 }{ \rtype_2 }{ \Type_j }{ \ttype_2 }
}{
\infer{ \Gamma }{ \Pi{x:\rtype_1}{\rtype_2} }{ \Type_{\max(i,j)} }{ \Pi{x:\ttype_1}{\ttype_2} }
}
\\[2em]
\rule{I-LAM}{
\infer{ \Gamma }{ \rtype }{ \Type_i }{ \ttype }
\qquad
\eval{ \Gamma }{ \ttype }{ \vtype_1 }
\qquad
\check{ \Gamma, x:\vtype_1 }{ \rexpr}{ \vtype_2 }{ \texpr }
}{
\infer{ \Gamma }{ \lam{x:\rtype}{\rexpr} }{ \Pi{x:\vtype_1}{\vtype_2} }{ \lam{x:\ttype}{\texpr} }
}
\\[2em]
\rule{I-APP}{
\infer{ \Gamma }{ \rexpr_1 }{ \Pi{x:\vtype_1}{\vtype_2} }{ \texpr_1 }
\qquad
\check{ \Gamma }{ \rexpr_2 }{ \vtype_1 }{ \texpr_2 }
\qquad
\eval{ \Gamma, x=\texpr_2 }{ \vtype_2 }{ \vtype_2' }
}{
\infer{ \Gamma }{ \rexpr_1 ~ \rexpr_2 }{ \vtype_2' }{ \texpr_1 ~ \texpr_2 }
}
\\[2em]
\end{array}
\]</p>
<a class="header" href="print.html#references" id="references"><h1>References</h1></a>
<p>What follows is a non-exhaustive list of some of the references that were useful
when building Pikelet:</p>
<ul>
<li>Charguéraud, Arthur (2011). “The Locally Nameless Representation”.
In <em>Journal of Automated Reasoning (JAR)</em>.
[<a href="http://www.chargueraud.org/softs/ln/">SITE</a>]
[<a href="http://www.chargueraud.org/research/2009/ln/main.pdf">PAPER</a>]</li>
<li>Christiansen, David Raymond (2013). “Bidirectional Typing Rules: A Tutorial”.
[<a href="http://www.davidchristiansen.dk/tutorials/bidirectional.pdf">PAPER</a>]</li>
<li>Löh, Andres, McBride, Conor and Swierstra, Wouter (2009). “A tutorial
implementation of a dependently typed lambda calculus”.
[<a href="https://www.andres-loeh.de/LambdaPi/">SITE</a>]
[<a href="https://www.andres-loeh.de/LambdaPi/LambdaPi.pdf">PAPER</a>]</li>
<li>Norell, Ulf (2007). “Towards a practical programming language based on
dependent type theory”.
[<a href="http://www.cse.chalmers.se/%7Eulfn/papers/thesis.pdf">PAPER</a>]</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script>
            document.addEventListener('DOMContentLoaded', function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
