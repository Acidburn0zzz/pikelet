use parse::{Term, ReplCommand};
use lalrpop_util::ParseError;

grammar();

pub ReplCommand : ReplCommand = {
    "" => ReplCommand::NoOp,
    ":h" => ReplCommand::Help,
    <Term> => ReplCommand::Eval(Box::new(<>)),
    ":t" <Term> => ReplCommand::TypeOf(Box::new(<>)),
};

pub Term: Term = {
    LamTerm,
    <x: Term> ":" <t: LamTerm> => {
        Term::Ann(Box::new(x), Box::new(t))
    },
};

LamTerm : Term = {
    PiTerm,
    r"\\" <x: Ident> "=>" <body: LamTerm> => {
        Term::Lam(x, None, Box::new(body))
    },
    r"\\" <x: Ident> ":" <ann: PiTerm> "=>" <body: LamTerm> => {
        Term::Lam(x, Some(Box::new(ann)), Box::new(body))
    },
};

PiTerm : Term = {
    AppTerm,
    // Naively we would want to write the following rules:
    //
    // ```lalrpop
    // "(" <x: Ident> ":" <ann: PiTerm> ")" "->" <body: LamTerm> => {
    //      Term::Pi(x, Box::new(ann), Box::new(body))
    //  },
    //  <ann: AppTerm> "->" <body: LamTerm> => {
    //      Term::Arrow(Box::new(ann), Box::new(body))
    //  },
    // ```
    //
    // Alas this causes an ambiguity with the `AtomicTerm` rule. Therefore we
    // have to hack this in with a dyncamic check:
    <binder: AtomicTerm> "->" <body: LamTerm> =>? {
        match binder {
            Term::Ann(x, ann) => match *x {
                Term::Var(x) => Ok(Term::Pi(x, ann, Box::new(body))),
                _ => Err(ParseError::User {
                    error: "identifier expected in pi type", // TODO: better error!
                }),
            },
            ann => Ok(Term::Arrow(Box::new(ann), Box::new(body)))
        }
    }
};

AppTerm: Term = {
    AtomicTerm,
    <f: AppTerm> <arg: AtomicTerm> => {
        Term::App(Box::new(f), Box::new(arg))
    },
};

AtomicTerm: Term = {
    "(" <Term> ")",
    "Type" => Term::Type,
    Ident => Term::Var(<>),
};

Ident: String = {
    r"[a-zA-Z][a-zA-Z0-9]*" => String::from(<>),
};
